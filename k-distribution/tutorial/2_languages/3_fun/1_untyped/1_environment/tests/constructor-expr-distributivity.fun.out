Solution 1
V ==K "(n * x + n * y)" andBool ( _0 ==K <env> .Map </env> andBool _1 ==K <store> 1 |-> closure ( toString |-> 1 distribute |-> 2 , ( Value ( n , .Exps ) -> n ) | ( ( Plus ( l , ( r , .Exps ) ) -> ( "(" ^ toString l ^ " + " ^ toString r ^ ")" ) ) | ( ( Minus ( l , ( r , .Exps ) ) -> ( "(" ^ toString l ^ " - " ^ toString r ^ ")" ) ) | ( ( Times ( l , ( r , .Exps ) ) -> ( toString l ^ " * " ^ toString r ) ) | .Cases ) ) ) ) 2 |-> closure ( toString |-> 1 distribute |-> 2 , ( Times ( e1 , ( Plus ( e2 , ( e3 , .Exps ) ) , .Exps ) ) -> ( Plus ( Times ( ( distribute e1 ) , ( ( distribute e2 ) , .Exps ) ) , ( Times ( ( distribute e1 ) , ( ( distribute e3 ) , .Exps ) ) , .Exps ) ) ) ) | ( ( Times ( Plus ( e1 , ( e2 , .Exps ) ) , ( e3 , .Exps ) ) -> ( Plus ( Times ( ( distribute e1 ) , ( ( distribute e3 ) , .Exps ) ) , ( Times ( ( distribute e2 ) , ( ( distribute e3 ) , .Exps ) ) , .Exps ) ) ) ) | ( ( Plus ( l , ( r , .Exps ) ) -> ( Plus ( ( distribute l ) , ( ( distribute r ) , .Exps ) ) ) ) | ( ( Minus ( l , ( r , .Exps ) ) -> ( Minus ( ( distribute l ) , ( ( distribute r ) , .Exps ) ) ) ) | ( ( Value ( n , .Exps ) -> ( Value ( n , .Exps ) ) ) | .Cases ) ) ) ) ) 3 |-> ( Value ( "x" , .Exps ) ) 4 |-> ( Value ( "y" , .Exps ) ) 5 |-> ( Value ( "n" , .Exps ) ) 6 |-> "y" 7 |-> "n" 8 |-> "x" 9 |-> "n" 10 |-> ( Times ( Value ( "n" , .Exps ) , ( Value ( "x" , .Exps ) , .Exps ) ) ) 11 |-> ( Times ( Value ( "n" , .Exps ) , ( Value ( "y" , .Exps ) , .Exps ) ) ) 12 |-> ( Value ( "n" , .Exps ) ) 13 |-> ( Value ( "y" , .Exps ) ) 14 |-> "y" 15 |-> "n" 16 |-> ( Value ( "n" , .Exps ) ) 17 |-> ( Value ( "x" , .Exps ) ) 18 |-> "x" 19 |-> "n" </store> )
