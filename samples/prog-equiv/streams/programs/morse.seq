/*
 This is an example of STREAM equivalence.
*/

<k> L.f($S:BSExp) </k>
<sspecs>
neg(x) := 1 <| x = 0 |> 0;
not(xs) :~ 1 <| hd(xs) = 0 |> 0 : not(tl(xs));
zip(xs, ys) :~ hd(xs) : L.zip(ys, tl(xs));
f(xs) :~ hd(xs) : L.(neg(hd(xs)) : L.f(tl(xs)));
</sspecs> 

~

<k> L.zip($S:BSExp, not($S:BSExp)) </k>
<sspecs>
neg(x) := 1 <| x = 0 |> 0;
not(xs) :~ 1 <| hd(xs) = 0 |> 0 : not(tl(xs));
zip(xs, ys) :~ hd(xs) : L.zip(ys, tl(xs));
f(xs) :~ hd(xs) : L.(neg(hd(xs)) : L.f(tl(xs)));
</sspecs> ;
                                  

<k> L.morse </k>
<sspecs>
not(xs) :~ 1 <| hd(xs) = 0 |> 0 : L.not(tl(xs));
zip(xs, ys) :~ hd(xs) : L.zip(ys, tl(xs));
morse :~ 0 : L.(1 : L.zip(tl(L.morse), L.not(tl(L.morse))));
</sspecs> 

~

<k> L.f(L.morse) </k>
<sspecs>
neg(x) := 1 <| x = 0 |> 0;
not(xs) :~ 1 <| hd(xs) = 0 |> 0 : L.not(tl(xs));
zip(xs, ys) :~ hd(xs) : L.zip(ys, tl(xs));
f(xs) :~ hd(xs) : L.(neg(hd(xs)) : L.f(tl(xs)));
morse :~ 0 : L.(1 : L.zip(tl(L.morse), L.not(tl(L.morse))));
</sspecs> ;

/*

<T>
    <goals>
        <goal>
            <config>
                <k>
                    morse ~> L . HOLE ~> tl ( HOLE ) ~> HOLE, ((L . (not (
                       ((tl ( (L . morse) ))) )))) ~> (zip `( HOLE`))
                </k>
                <out>
                    0 : (1 : [])
                </out>
                <sspecs>
                    morse |-> lambda ( .Ids ) (0 : (L . (1 : (L . (zip ( (
                      (tl ( (L . morse) )), ((L . (not ( ((tl ( (L . morse) ))
                      ) ))))) ))))))
                    not |-> lambda ( xs ) ((1 <| ((hd ( xs )) = 0) |> 0) : (L 
                      . (not ( ((tl ( xs ))) ))))
                    zip |-> lambda ( (xs, ys) ) ((hd ( xs )) : (L . (zip ( (ys
                      , ((tl ( xs )))) ))))
                </sspecs>
            </config>
            <config>
                <k>
                    f ( ((L . (1 : (L . (zip ( ((tl ( (L . morse) )), ((L 
                      . (not ( ((tl ( (L . morse) ))) ))))) )))))) )
                </k>
                <out>
                    0 : (1 : [])
                </out>
                <sspecs>
                    f |-> lambda ( xs ) ((hd ( xs )) : (L . ((neg ( ((hd (
                       xs ))) )) : (L . (f ( ((tl ( xs ))) ))))))
                    morse |-> lambda ( .Ids ) (0 : (L . (1 : (L . (zip ( ((tl 
                      ( (L . morse) )), ((L . (not ( ((tl ( (L . morse) ))) ))
                      ))) ))))))
                    neg |-> lambda ( x ) (1 <| (x = 0) |> 0)
                    not |-> lambda ( xs ) ((1 <| ((hd ( xs )) = 0) |> 0) : (L 
                      . (not ( ((tl ( xs ))) ))))
                    zip |-> lambda ( (xs, ys) ) ((hd ( xs )) : (L . (zip ( (ys
                      , ((tl ( xs )))) ))))
                </sspecs>
            </config>
            <kb>
                .Map
            </kb>
        </goal>
    </goals>
    <hypos>
        <hypo>
            <patt1>
                <hout1>
                    0 : (1 : [])
                </hout1>
                <hk1>
                    f ( ((L . (1 : (L . (zip ( ((tl ( (L . morse) )), ((L 
                      . (not ( ((tl ( (L . morse) ))) ))))) )))))) )
                </hk1>
            </patt1>
            <patt2>
                <hout2>
                    0 : (1 : [])
                </hout2>
                <hk2>
                    zip ( ((tl ( (L . morse) )), ((L . (not ( ((tl ( (L . 
                      morse) ))) ))))) )
                </hk2>
            </patt2>
        </hypo>
        <hypo>
            <patt1>
                <hout1>
                    0 : []
                </hout1>
                <hk1>
                    zip ( ((1 : (not ( $S:BSExp ))), $S:BSExp) )
                </hk1>
            </patt1>
            <patt2>
                <hout2>
                    0 : []
                </hout2>
                <hk2>
                    (neg ( 0 )) : (L . (f ( $S:BSExp )))
                </hk2>
            </patt2>
        </hypo>
        <hypo>
            <patt1>
                <hout1>
                    0 : []
                </hout1>
                <hk1>
                    (neg ( 0 )) : (L . (f ( ((L . (1 : (L . (zip ( ((tl ( 
                      (L . morse) )), ((L . (not ( ((tl ( (L . morse) ))) ))))
                      ) )))))) )))
                </hk1>
            </patt1>
            <patt2>
                <hout2>
                    0 : []
                </hout2>
                <hk2>
                    1 : (L . (zip ( ((tl ( (L . morse) )), ((L . (not ( ((
                      tl ( (L . morse) ))) ))))) )))
                </hk2>
            </patt2>
        </hypo>
        <hypo>
            <patt1>
                <hout1>
                    []
                </hout1>
                <hk1>
                    f ( ((L . morse)) )
                </hk1>
            </patt1>
            <patt2>
                <hout2>
                    []
                </hout2>
                <hk2>
                    morse
                </hk2>
            </patt2>
        </hypo>
        <hypo>
            <patt1>
                <hout1>
                    []
                </hout1>
                <hk1>
                    (f `( $S:BSExp`))
                </hk1>
            </patt1>
            <patt2>
                <hout2>
                    []
                </hout2>
                <hk2>
                    (zip `( $S:BSExp, ((not ( $S:BSExp )))`))
                </hk2>
            </patt2>
        </hypo>
    </hypos>
</T>

*/